# match_firmware
记录整个查找过程的运行逻辑，以及过程中各个信息存储模式

### 基础程序描述
1. 文件解包：使用`binwalk`将文件解压在`temp`文件夹中，`binwalk`解包后生成的文件夹名为 `_bin_file_name.bin.extracted`，所有的查找操作都是围绕这个文件夹进行的。
2. 构建数据库链接：这里使用的`sqlalchemy`中的数据库引擎，可以简单进行数据库操作，用`pandas`来存储返回的数据，这样可以存储比较规范化的数据，相较于数组有较好的可视性。
3. 获取数据库所有的公司名称，使用`grep`指令在`temp`文件中来进行依次进行比对查找，这样可以获取一个列表`may_vendors`，即在解包文件中出现的公司名称列表。注：公司名称的过滤，需要考虑很多特殊情况，比如公司名称出现在单词中等。
4. 根据`may_vendors`获取该公司下的所有设备型号，同样使用`grep`指令在`temp`文件夹中进行比对查找。
5. 如果该解包文件同时出现公司名称以及该公司下的某个或某些设备信息，那么我们可以认定该固件是服务于这些设备的。
6. 其他情况，如出现无法匹配公司，无法匹配型号等情况，需要按照逻辑设计记录在对应的log文件中，具体详见逻辑说明文件

### 设计要求
##### 变量名称设计要求

变量名称，这里记录频繁出现的如公司等变量的统一命名，其他的安装python命名规范设计名称

|  实际指代  |      变量名称       |
| :--------: | :-----------------: |
| 公司[列表] |   vendor[vendors]   |
| 设备[列表] |    model[models]    |
| 固件[列表] | firmware[firmwares] |

##### 函数设计要求

1. 函数名称按照python设计规范，多单词以下划线链接
2. 函数名称需要能够直观的了解具体执行任务，尽量一个函数只干一件事
3. 与数据库操作相关的，以具体操作开头，如select，insert等
4. 函数注释的标注

##### 工具设计要求

1. 工具设计统一建立在tools包下
2. 文件名明确是用于那个方面的

### 比对细节描述
比对厂商信息，可能出现的结果：

1. [] 空数组，无匹配信息的bin文件名称记入nomatch.log
2. ['vendor1'] 单个厂商，执行型号查询操作，后执行step2
3. ['vendor1', 'vendor2'...] 多个厂商，执行型号查询操作，后执行step2

型号查询操作：在数据库里select数据

输入['vendor1', 'vendor2',...]

输出
{
    'vendor1':['model1', 'model2', ...],
    'vendor2':['model1', 'model2', ...],
    ...
}
如果输入就一个，那输出的也就一行数据。

比对型号信息，将型号查询操作的结果依次比对，可能出现的结果:

1. {} 无匹配，grep结果记录在，noModel_厂商_bin文件名.log 文件名的，厂商为型号查询操作的输入
2. {'vendor1':['model1']} 一对一匹配，将grep结果记录在 vendor1_model1_bin文件名.log
3. {'vendor1':['model1', 'model2', ...]} 
  一对多匹配，将grep结果记录在 vendor1_model1_model2_..._bin文件名.log
4. {
    'vendor1':['model1', 'model2', ...],
    'vendor2':['model1', 'model2', ...],
    ...
} 多厂商均命中，操作待定。

